#ifndef TRRE_H
#define TREE_H
#define max(x, y) (((x) > (y)) ? (x) : (y))
#define min(x, y) (((x) < (y)) ? (x) : (y))
#include "T.h"

/*------------------------------------------------------------------------------
  Функция: возвращает индекс, соответствующий левым дочерним элементам узла.
  Вход: целое число i, указывающее текущую позицию в векторе.
  Вывод: целое число с новой позицией.
------------------------------------------------------------------------------*/
int get_left(int i);

/*------------------------------------------------------------------------------
  Функция: возвращает индекс, соответствующий правым дочерним элементам узла.
  Вход: целое число i, указывающее текущую позицию в векторе.
  Вывод: целое число с новой позицией.
------------------------------------------------------------------------------*/
int get_right(int i);

/*------------------------------------------------------------------------------
  Функция: возвращает середину вектора.
  Входные данные: целые числа l и r, представляющие диапазон вектора [l, r].
  Выход: целое число с позицией.
------------------------------------------------------------------------------*/
int get_mid(int l, int r);

/*------------------------------------------------------------------------------
  Функция: строит дерево сегментации с его 2n-1 узлами, вычисляя кортеж
  совпадает только один раз.
  Вход: вектор типа T (кортеж), который будет деревом, вектор v, содержащий
  элементы, которые будут использоваться как ссылка, индекс корня
  и целые числа, соответствующие диапазону вектора v ([l=1, r=N]).
  Вывод: без возврата.
------------------------------------------------------------------------------*/
void BuildSegTree(T tree[], int v[], int index, int l, int r);

/*------------------------------------------------------------------------------
  Функция: добавить 1 к элементам диапазона (листовым узлам) [L, R] и обновить
  все его предыдущие узлы вплоть до корня.
  Вход: вектор типа T, который будет деревом, корневой индекс (1),
  диапазон вектора v [l=1, r=N] и диапазон, в котором вы хотите
  выполнить операцию [L, R].
  Вывод: без возврата.
------------------------------------------------------------------------------*/
void add(T tree[], int index, int l, int r, int L, int R);

/*------------------------------------------------------------------------------
  Функция: вычитает 1 из элементов диапазона (листовых узлов) [L, R] и обновляет
  все его предыдущие узлы вплоть до корня.
  Вход: вектор типа T, который будет деревом, индекс корня (1),
  диапазон вектора v [l=1, r=N] и диапазон, в котором вы хотите
  выполнить операцию [L, R].
  Вывод: без возврата.
------------------------------------------------------------------------------*/
void sub(T tree[], int index, int l, int r, int L, int R);

/*------------------------------------------------------------------------------
  Функция: запрос суммы заданного диапазона.
  Вход: вектор типа T, который будет деревом, индекс корня (1),
  диапазон вектора v [l=1, r=N] и диапазон, в котором вы хотите
  извлеките сумму [L, R].
  Выход: сумма рассматриваемого диапазона.
------------------------------------------------------------------------------*/
int computeSum(T tree[], int index, int l, int r, int L, int R);

/*------------------------------------------------------------------------------
  Функция: Запросить минимальное значение заданного диапазона.
  Вход: вектор типа T, который будет деревом, индекс корня (1),
  диапазон вектора v [l=1, r=N] и диапазон, в котором вы хотите
  извлеките минимум [L, R].
  Выход: минимальное значение рассматриваемого диапазона.
------------------------------------------------------------------------------*/
int computeMin(T tree[], int index, int l, int r, int L, int R);

/*------------------------------------------------------------------------------
  Функция: Запрос максимального значения заданного диапазона.
  Вход: вектор типа T, который будет деревом, индекс корня (1),
  диапазон вектора v [l=1, r=N] и диапазон, в котором вы хотите
  извлечь максимум [L, R].
  Выход: максимальное значение рассматриваемого диапазона.
------------------------------------------------------------------------------*/
int computeMax(T tree[], int index, int l, int r, int L, int R);

#endif
